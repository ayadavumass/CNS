package edu.umass.cs.contextservice.gns;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.InetSocketAddress;
import java.security.KeyPair;
import java.security.NoSuchAlgorithmException;
import java.util.LinkedList;
import java.util.logging.Logger;

import org.json.JSONArray;

import edu.umass.cs.contextservice.GroupGUIDInfo;
import edu.umass.cs.contextservice.database.records.GroupGUIDRecord;
import edu.umass.cs.contextservice.logging.ContextServiceLogger;
import edu.umass.cs.contextservice.utils.Utils;
import edu.umass.cs.gns.client.GnsProtocol;
import edu.umass.cs.gns.client.GuidEntry;
import edu.umass.cs.gns.client.UniversalTcpClient;
import edu.umass.cs.gns.client.util.KeyPairUtils;
import edu.umass.cs.gns.exceptions.GnsException;

/**
 * Interface that provides GNS calls
 * 
 * attribute metadata format
 * Metadata:AttributeName
 * @author ayadav
 */
public class GNSCalls
{
	//public static String gnsHost = "ananas.cs.umass.edu";
	// NIO LNS port
	//public static int gnsPort = 24398;
	
	public static enum UserGUIDOperations {ADD_USER_GUID_TO_GROUP, REMOVE_USER_GUID_FROM_GROUP};
	
	private final static Logger log = ContextServiceLogger.getLogger();	
	
	/**
	 * takes alias of group, which is query and reads groupmembers
	 * @param query
	 * @return guids of group members
	 */
	public static JSONArray readGroupMembers(String query)
	{
		String defaultGns = KeyPairUtils.getDefaultGnsFromPreferences();
		String[] parsed = defaultGns.split(":");
		String gnsHost = parsed[0];
		int gnsPort = Integer.parseInt(parsed[1]);
		
		JSONArray grpMem = null;
		UniversalTcpClient gnsClient = new UniversalTcpClient(gnsHost, gnsPort);
		
		try 
		{
			String queryHash = Utils.getSHA1(query);
			
			GuidEntry myGuidEntry = KeyPairUtils.getDefaultGuidEntryFromPreferences(defaultGns);
			
			String guidString = gnsClient.lookupGuid(queryHash);
			// group should be read by all, atleast for now
			grpMem = gnsClient.groupGetMembers(guidString, myGuidEntry);
		} catch (UnsupportedEncodingException e)
		{
			e.printStackTrace();
		} catch (IOException e)
		{
			e.printStackTrace();
		} catch (GnsException e)
		{
			log.info("GnsException no group exists");
			//e.printStackTrace();
		} catch (NoSuchAlgorithmException e) 
		{
			e.printStackTrace();
		}
		return grpMem;
	}
	
	
	/**
	 * creates the group for a query, adding 
	 * query as the alias.
	 * Initially the group is empty but 
	 * GUIDs are added as soon as query processing is 
	 * complete.
	 * @return groupGUID if successfull otherwise empty string
	 */
	public static String createQueryGroup(String queryString)
	{
		String groupGUIDString = "";
		
		try
		{
			String queryHash = Utils.getSHA1(queryString);
			
			String defaultGns = KeyPairUtils.getDefaultGnsFromPreferences();
			
			String[] parsed = defaultGns.split(":");
			String gnsHost = parsed[0];
			int gnsPort = Integer.parseInt(parsed[1]);
			
			GuidEntry myGuidEntry = KeyPairUtils.getDefaultGuidEntryFromPreferences(defaultGns);
			
			UniversalTcpClient gnsClient = new UniversalTcpClient(gnsHost, gnsPort);
			
		    GuidEntry groupGuid = KeyPairUtils.getGuidEntryFromPreferences(defaultGns, queryHash);
		    
		    /*
		     * Take a lock on the GNS connection object to prevent concurrent queries to
		     * the GNS on the same connection as the library is not thread-safe from
		     * that standpoint.
		     */
		    synchronized (gnsClient)
		    {
		    	// should not be existing before
		    	if (groupGuid == null)
		    	{
		    		log.info("No group exisits " + queryString + " and hash +"+queryHash+". Generating new GUID and keys");
		    		// Create a new GUID
		    		groupGuid = gnsClient.guidCreate(myGuidEntry, queryHash);
		    		
		    		// save keys in the preference
		    		System.out.println("saving keys to local");
		    		KeyPairUtils.saveKeyPairToPreferences(KeyPairUtils.getDefaultGnsFromPreferences(), 
		    			  groupGuid.getEntityName() , groupGuid.getGuid(), 
		    			  new KeyPair(groupGuid.getPublicKey(), groupGuid.getPrivateKey()));
		
		    		// storing alias in gns record, need it to find it when we have GUID
		    		// from group members
		    		
		    		//gnsClient.addAlias(groupGuid, queryHash);
		    		groupGUIDString = groupGuid.getGuid();
		    		
		    		gnsClient.groupAddMembershipReadPermission(groupGuid, GnsProtocol.ALL_USERS);
		    		//gnsClient.fieldCreate(groupGuid.getGuid(), ALIAS_FIELD, new JSONArray().put(name), myGuid);
		    	} else
		    	{
		    		log.info("group already exists, just reseting the group");
		    		//FIXME: need one command to reset the group.
		    		JSONArray jsonMem = gnsClient.groupGetMembers(groupGuid.getGuid(), groupGuid);
		    		gnsClient.groupRemoveGuids(groupGuid.getGuid(), jsonMem, groupGuid);
		    	}
		    	
		    	//Put the IP address in the GNS
		    	//String ipPort = saddr.getAddress().getHostAddress() + ":" + saddr.getPort();
		    	//log.trace("Updating " + GnsConstants.SERVER_REG_ADDR + " GNSValue " + ipPort);
		    	//gnsClient
		    	//.fieldReplaceOrCreate(myGuid.getGuid(), GnsConstants.SERVER_REG_ADDR, 
		    	//new JSONArray().put(ipPort), myGuid);
		    }
		} catch(Exception ex)
		{
			ex.printStackTrace();
		}
		return groupGUIDString;
	}
	
	/**
	 * Adds multiple User GUIDs to a single group
	 * @param guidsList
	 * @param queryString
	 */
	public static void addGUIDsToGroup(JSONArray guidsList, String queryString)
	{
		try
		{
			String queryHash = Utils.getSHA1(queryString);
			
			String defaultGns = KeyPairUtils.getDefaultGnsFromPreferences();
			
			String[] parsed = defaultGns.split(":");
			String gnsHost = parsed[0];
			int gnsPort = Integer.parseInt(parsed[1]);
			
			//GuidEntry myGuidEntry = KeyPairUtils.getDefaultGuidEntryFromPreferences(defaultGns);
			
			UniversalTcpClient gnsClient = new UniversalTcpClient(gnsHost, gnsPort);
			
		    GuidEntry groupGuid = KeyPairUtils.getGuidEntryFromPreferences(defaultGns, queryHash);
		    
		    /*
		     * Take a lock on the GNS connection object to prevent concurrent queries to
		     * the GNS on the same connection as the library is not thread-safe from
		     * that standpoint.
		     */
		    synchronized (gnsClient)
		    {
		      if(groupGuid!=null)
		      {
		    	  gnsClient.groupAddGuids(groupGuid.getGuid(), guidsList, groupGuid);
		      }
		      else
		      {
		    	  assert(false);
		      }
		    }
		} catch(Exception ex)
		{
			ex.printStackTrace();
		}
	}
	
	/**
	 * removes a single user GUID from list of group GUIDs
	 * @param guidsList
	 * @param queryString
	 */
	public static void userGUIDAndGroupGUIDOperations(String userGUID, LinkedList<GroupGUIDRecord> groupGUIDList,
			UserGUIDOperations oper)
	{
		try
		{
			String defaultGns = KeyPairUtils.getDefaultGnsFromPreferences();
			
			String[] parsed = defaultGns.split(":");
			String gnsHost = parsed[0];
			int gnsPort = Integer.parseInt(parsed[1]);
			
			//GuidEntry myGuidEntry = KeyPairUtils.getDefaultGuidEntryFromPreferences(defaultGns);
			
			UniversalTcpClient gnsClient = new UniversalTcpClient(gnsHost, gnsPort);
			
			for(int i=0;i<groupGUIDList.size();i++)
			{
				GroupGUIDRecord grpGUIDInfo = groupGUIDList.get(i);
				String queryString = grpGUIDInfo.getGroupQuery();
				
				String queryHash = Utils.getSHA1(queryString);
				
				GuidEntry groupGuid = KeyPairUtils.getGuidEntryFromPreferences(defaultGns, queryHash);
			    
			    /*
			     * Take a lock on the GNS connection object to prevent concurrent queries to
			     * the GNS on the same connection as the library is not thread-safe from
			     * that standpoint.
			     */
			    synchronized (gnsClient)
			    {
			      if(groupGuid!=null)
			      {
			    	  switch(oper)
			    	  {
			    	  	case ADD_USER_GUID_TO_GROUP:
			    	  	{
			    	  		gnsClient.groupAddGuid(groupGuid.getGuid(), userGUID, groupGuid);
			    	  		break;
			    	  	}
			    	  	case REMOVE_USER_GUID_FROM_GROUP:
			    	  	{
			    	  		gnsClient.groupRemoveGuid(groupGuid.getGuid(), userGUID, groupGuid);
			    	  		break;
			    	  	}
			    	  }
			      }
			      else
			      {
			    	  assert(false);
			      }
			    }
			    
			}
		} catch(Exception ex)
		{
			ex.printStackTrace();
		}
	}
	
	
	/**
	 * adds the given address in the notification set
	 * @param socketAddress
	 * @param groupQuery
	 */
	public static void updateNotificationSetOfAGroup(InetSocketAddress socketAddress, String groupQuery)
	{
		try
		{
			String defaultGns = KeyPairUtils.getDefaultGnsFromPreferences();
			
			String[] parsed = defaultGns.split(":");
			String gnsHost = parsed[0];
			int gnsPort = Integer.parseInt(parsed[1]);
			
			//GuidEntry myGuidEntry = KeyPairUtils.getDefaultGuidEntryFromPreferences(defaultGns);
			
			UniversalTcpClient gnsClient = new UniversalTcpClient(gnsHost, gnsPort);
			
			String queryHash = Utils.getSHA1(groupQuery);
				
			GuidEntry groupGuid = KeyPairUtils.getGuidEntryFromPreferences(defaultGns, queryHash);
			    
		    /*
		     * Take a lock on the GNS connection object to prevent concurrent queries to
		     * the GNS on the same connection as the library is not thread-safe from
		     * that standpoint.
		     */
		    synchronized (gnsClient)
		    {
		      if(groupGuid!=null)
		      {
		    	  String addrString = socketAddress.getAddress().getHostAddress()+":"+socketAddress.getPort();
		    	  JSONArray arr = new JSONArray();
		    	  arr.put(addrString);
		    	  gnsClient.fieldAppend(groupGuid.getGuid(), GnsConstants.NOTIFICATION_SET, arr, groupGuid);
		      }
		      else
		      {
		    	  assert(false);
		      }
		    }
		    
		} catch(Exception ex)
		{
			ex.printStackTrace();
		}
	}
	
	
	public static JSONArray getNotificationSetOfAGroup(String groupQuery)
	{
		JSONArray result = new JSONArray();
		try
		{
			String defaultGns = KeyPairUtils.getDefaultGnsFromPreferences();
			
			String[] parsed = defaultGns.split(":");
			String gnsHost = parsed[0];
			int gnsPort = Integer.parseInt(parsed[1]);
			
			//GuidEntry myGuidEntry = KeyPairUtils.getDefaultGuidEntryFromPreferences(defaultGns);
			
			UniversalTcpClient gnsClient = new UniversalTcpClient(gnsHost, gnsPort);
			
			String queryHash = Utils.getSHA1(groupQuery);
				
			GuidEntry groupGuid = KeyPairUtils.getGuidEntryFromPreferences(defaultGns, queryHash);
			    
		    /*
		     * Take a lock on the GNS connection object to prevent concurrent queries to
		     * the GNS on the same connection as the library is not thread-safe from
		     * that standpoint.
		     */
		    synchronized (gnsClient)
		    {
		      if(groupGuid!=null)
		      {
		    	  result = gnsClient.fieldReadArray(groupGuid.getGuid(), GnsConstants.NOTIFICATION_SET, groupGuid);
		      }
		      else
		      {
		    	  assert(false);
		      }
		    }
		    
		} catch(Exception ex)
		{
			ex.printStackTrace();
		}
		return result;
	}
	
	
	public static void clearNotificationSetOfAGroup(String groupQuery)
	{
		try
		{
			String defaultGns = KeyPairUtils.getDefaultGnsFromPreferences();
			
			String[] parsed = defaultGns.split(":");
			String gnsHost = parsed[0];
			int gnsPort = Integer.parseInt(parsed[1]);
			
			//GuidEntry myGuidEntry = KeyPairUtils.getDefaultGuidEntryFromPreferences(defaultGns);
			
			UniversalTcpClient gnsClient = new UniversalTcpClient(gnsHost, gnsPort);
			
			String queryHash = Utils.getSHA1(groupQuery);
				
			GuidEntry groupGuid = KeyPairUtils.getGuidEntryFromPreferences(defaultGns, queryHash);
			    
		    /*
		     * Take a lock on the GNS connection object to prevent concurrent queries to
		     * the GNS on the same connection as the library is not thread-safe from
		     * that standpoint.
		     */
		    synchronized (gnsClient)
		    {
		      if(groupGuid!=null)
		      {
		    	  gnsClient.fieldClear(groupGuid.getGuid(), GnsConstants.NOTIFICATION_SET, groupGuid);
		      }
		      else
		      {
		    	  assert(false);
		      }
		    }
		    
		} catch(Exception ex)
		{
			ex.printStackTrace();
		}
		
	}
	
	
	/*public static void checkIfAttributeMetadataExists(String attributeName)
	{
		try
		 {
		    UniversalGnsClient gnsClient = new UniversalGnsClient(gnsHost, gnsPort);
		    String guidString = gnsClient.lookupGuid(attributeName);
		    
		    JSONArray resultArray;
		    // Read from the GNS
		    synchronized (gnsClient)
		    {
		      resultArray = gnsClient.fieldRead(guidString, GnsConstants.SERVER_REG_ADDR, null);
		    }
		    Vector<InetSocketAddress> resultVector = new Vector<InetSocketAddress>();
		    for (int i = 0; i < resultArray.length(); i++)
		    {
		      String str = resultArray.getString(i);
		      log.fine("Value returned from GNS " + str);
		      String[] Parsed = str.split(":");
		      InetSocketAddress socketAddress = new InetSocketAddress(Parsed[0], Integer.parseInt(Parsed[1]));
		      resultVector.add(socketAddress);
		    }
		    return resultVector;
		 } catch(Exception ex)
		 {
			 ex.printStackTrace();
			 throw new UnknownHostException(ex.toString());
		 }
	}*/
	
	
	/**
	 * Checks if the group for the given query already 
	 * exists. Query is used as an alias to look for the
	 * GroupGUID, if that fails then no such group exisits.
	 * Works only if queries are exactly same in string
	 * representation.
	 * @param query
	 * @return
	 */
	/*public static String checkIfGroupForQueryExists(String query)
	{
		String defaultGns = KeyPairUtils.getDefaultGnsFromPreferences();
		String[] parsed = defaultGns.split(":");
		String gnsHost = parsed[0];
		int gnsPort = Integer.parseInt(parsed[1]);
		
		String guidString = "";
		UniversalTcpClient gnsClient = new UniversalTcpClient(gnsHost, gnsPort);
		
		try 
		{
			guidString = gnsClient.lookupGuid(query);
			
		} catch (UnsupportedEncodingException e)
		{
			e.printStackTrace();
		} catch (IOException e)
		{
			e.printStackTrace();
		} catch (GnsException e)
		{
			log.info("GnsException no group exists");
			//e.printStackTrace();
		}
		return guidString;
	}*/
}