package edu.umass.cs.contextservice.utils;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.Vector;
import java.util.logging.Logger;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import com.google.common.hash.Hashing;

import edu.umass.cs.contextservice.AttributeMetadataObject;
import edu.umass.cs.contextservice.config.ContextServiceConfig;
import edu.umass.cs.contextservice.database.records.AttributeMetaObjectRecord;
import edu.umass.cs.contextservice.logging.ContextServiceLogger;
import edu.umass.cs.contextservice.messages.MetadataMsgToValuenode;
import edu.umass.cs.contextservice.messages.ValueUpdateMsgToValuenode;
import edu.umass.cs.contextservice.processing.QueryComponent;
import edu.umass.cs.contextservice.processing.QueryParser;
import edu.umass.cs.gns.nio.GenericMessagingTask;

/**
 * Class specifies the common utility methods like SHA1 hashing etc.
 * @author ayadav
 *
 */
public class Utils
{
	private static final Logger LOGGER = ContextServiceLogger.getLogger();
	
	/**
	   * convert byte[] GUID into String rep of hex, for indexing at proxy
	   * 
	   * @param a
	   * @return
	   */
	  public static String bytArrayToHex(byte[] a)
	  {
	    StringBuilder sb = new StringBuilder();

	    for (byte b : a)
	      sb.append(String.format("%02x", b & 0xff));

	    String toBeReturned = sb.toString();
	    toBeReturned = toBeReturned.toUpperCase();
	    return toBeReturned;
	  }
	  
	  public static byte[] hexStringToByteArray(String s) 
	  {
		  int len = s.length();
		  byte[] data = new byte[len / 2];
		  for (int i = 0; i < len; i += 2) 
		  {
			  data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
					  + Character.digit(s.charAt(i+1), 16));
		  }
		  return data;
	  }
	  
	  /**
	   * takes list of elements as input and returns the
	   * conjunction over list of elements.
	   * @param elements
	   * @return
	   */
	  public static JSONArray doConjuction(LinkedList<LinkedList<String>> elements)
	  {
		  LinkedList<String> result = new LinkedList<String>();
		  int numPredicates = elements.size();
		  //System.out.println(" numPredicates "+numPredicates);
		  HashMap<String, Integer> conjuctionMap = new HashMap<String, Integer>();
		  for (int i=0;i<elements.size();i++)
		  {
			  LinkedList<String> currList = elements.get(i);
			  for(int j=0;j<currList.size();j++)
			  {
				  String curString = currList.get(j);
				  Integer count = conjuctionMap.get(curString);
				  if(count == null)
				  {
					  //System.out.println("Key "+curString);
					  conjuctionMap.put(curString, 1);
				  } 
				  else
				  {
					  //System.out.println("Key++ "+curString+", "+count+1);
					  conjuctionMap.put(curString, count+1);
				  }
			  }
		  }
		  
		  for (Map.Entry<String, Integer> entry : conjuctionMap.entrySet()) 
		  {
			    String key = entry.getKey();
			    Integer value = entry.getValue();
			    if(value == numPredicates)
			    {
			    	result.add(key);
			    }
		  }
		  
		  JSONArray resultJSON = new JSONArray();
		  
		  for(int i=0;i<result.size();i++)
		  {
			  resultJSON.put(result.get(i));
		  }
		  //System.out.println("conjuctionMap "+conjuctionMap);
		  return resultJSON;
	  }
	  
	  
	  /**
	   * checks if the input attr value lies within the range
	   * @return
	   */
	public static boolean checkQCForOverlapWithValue(double attrValue, QueryComponent qc)
	{
		if( (qc.getLeftValue() <= attrValue) && (qc.getRightValue() > attrValue) )
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
	
	/**
	 * Takes all the context attributes, new and the old values, 
	 * checks if the group query is still satisfied or not.
	 * @return
	 * @throws JSONException 
	 * @throws NumberFormatException 
	 */
	public static boolean groupMemberCheck(JSONObject allAttr, String updateAttrName
			, double attrVal, String groupQuery) 
			throws JSONException
	{
		boolean satisfiesGroup = true;
		Vector<QueryComponent> groupQC = QueryParser.parseQuery(groupQuery);
		
		for(int j=0;j<groupQC.size();j++)
		{
			QueryComponent qc = groupQC.get(j);
			String attrName = qc.getAttributeName();
				
			// if this is the case, don't use the given val
			if(attrName.equals(updateAttrName))
			{
				// values are indexed by attr names
				double recValue = attrVal;
				boolean checkRes = Utils.checkQCForOverlapWithValue(recValue, qc);
				
				// if not satisfies, then group not satisfied
				if(!checkRes)
				{
					satisfiesGroup = false;
					break;
				}
					
			} else
			{
				// values are indexed by attr names
				double recValue = Double.parseDouble(allAttr.getString(attrName));
				boolean checkRes = Utils.checkQCForOverlapWithValue(recValue, qc);
				
				// if not satisfies, then group not satisfied
				if(!checkRes)
				{
					satisfiesGroup = false;
					break;
				}
			}
		}
		return satisfiesGroup;
	}
	
	
	/*public static String getSHA1(String stringToHash) throws NoSuchAlgorithmException
	{
	   //Hashing.consistentHash(input, buckets);
	   MessageDigest md = MessageDigest.getInstance("SHA-256");
       md.update(stringToHash.getBytes());
 
       byte byteData[] = md.digest();
 
       //convert the byte to hex format method 1
       StringBuffer sb = new StringBuffer();
       for (int i = 0; i < byteData.length; i++) 
       {
       		sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));
       }
 
       LOGGER.fine("Hex format : " + sb.toString());
       return sb.toString();
	}*/
}